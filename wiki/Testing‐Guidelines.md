### テスト規約（フェーズ1）

#### 1. **テストの目的**
   テストは、以下の目的を持って実施します：
   - システムの各機能が意図通りに動作することを確認する。
   - バグの早期発見と修正。
   - システムのリファクタリングが既存機能に影響を与えないことを確認する。

---

#### 2. **テストの分類**
   - **単体テスト（Unit Test）**  
     各機能やモジュール（クラスや関数）の最小単位で、個別にテストを行います。モジュール単位で、入力と出力を確認し、正しく処理が行われるかを検証します。
     
   - **統合テスト（Integration Test）**  
     複数のモジュールやコンポーネントを組み合わせて動作確認します。データの流れや、他のシステムとの連携に問題がないかをチェックします。

   - **エンドツーエンドテスト（E2E Test）**  
     最終的なユーザー視点でシステム全体の動作確認を行います。特に、シミュレーション内でのエージェントの行動や、取引システムなどの主要なフローに対して確認します。

---

#### 3. **テストツール**
   フェーズ1では、以下のテストツールを使用します：
   - **Google Test（gtest）**  
     C++用のテストフレームワークで、単体テストと統合テストを実施します。
   - **CMakeと統合**  
     CMakeのビルドプロセスにテストを組み込み、テストが自動的に実行されるようにします。

---

#### 4. **テストケースの命名規則**
   テストケースは一貫性を持たせるために、以下の命名規則を守ります：
   - **形式**：`<機能名>_<入力条件>_<期待結果>`
     - 例：`Agent_Trade_Success`（エージェントが取引を行った結果、成功する）
   - 機能名：テスト対象のモジュールや機能の名前。
   - 入力条件：特定の入力や条件を示す。
   - 期待結果：テストの期待される結果を示す。

---

#### 5. **テストケースの基本ルール**
   - **1つのテストケースは1つの機能を確認する**  
     各テストケースは、単一の機能を検証することに集中します。複数の機能をテストする場合は、複数のテストケースを作成します。
   - **テストケースは独立して実行可能であること**  
     テストケースは他のテストケースに依存せず、単独で実行できる必要があります。テスト実行の順番に依存しないようにします。
   - **失敗したテストはすぐに修正する**  
     失敗したテストは、システムがその通りに動作していないことを示しているため、早急に修正します。

---

#### 6. **テストのカバレッジ**
   > **重要**: フェーズ1ではコードカバレッジ収集を行いません。以下の項目はフェーズ2以降で適用されます。
   
   - **カバレッジ対象**
     フェーズ2以降では、以下の機能に対するテストカバレッジを確保します：
     - エージェントの基本的な行動（農民、貴族など）
     - 取引システムの動作確認（貴族と農民間の資産交換）
     - 健康状態や犯罪傾向など、エージェントの状態管理
   - **カバレッジ目標**
     - 単体テストのカバレッジは80%以上を目標にします。
     - 統合テストとエンドツーエンドテストを含めて、重要なフローをカバーします。

---

#### 7. **テストの実行と自動化**
   - **CI（継続的インテグレーション）**
     GitHub Actionsなどを利用して、コードがプッシュされるたびに自動的にテストが実行されるようにします。
   - **テストレポート**
     テストが失敗した場合、GitHub Actionsのログに詳細なレポートが出力されるように設定します。また、定期的にテスト結果をチームで確認できるようにします。
   > **注意**: フェーズ1ではカバレッジレポートは生成されません。

---

#### 8. **テストケースの例**

   - **エージェントの生成**
     ```cpp
     TEST(Agent, Creation) {
         Agent agent("Farmer", 100);  // 農民エージェントを100の資産で作成
         EXPECT_EQ(agent.getType(), "Farmer");  // エージェントのタイプが「Farmer」であること
         EXPECT_EQ(agent.getAssets(), 100);  // 資産が100であること
     }
     ```

   - **取引成功**
     ```cpp
     TEST(Agent_Trade, Success) {
         Agent farmer("Farmer", 100);
         Agent noble("Noble", 200);
         bool result = farmer.trade(noble, 50);  // 農民が貴族に50を渡す取引
         EXPECT_TRUE(result);  // 取引が成功すること
         EXPECT_EQ(farmer.getAssets(), 50);  // 農民の資産が50になること
         EXPECT_EQ(noble.getAssets(), 250);  // 貴族の資産が250になること
     }
     ```

---

#### 9. **テストコードの管理**
   - テストコードは、各機能ごとにモジュール化して管理します。
   - テストコードは、`tests` ディレクトリ内に配置し、各モジュールごとにサブディレクトリを作成します。
     - 例：`tests/agent/AgentTest.cpp`

---

#### 10. **テストのレビュー**
   - テストコードは実装後、必ず他のチームメンバーによるレビューを受けるようにします。レビューによって、テストケースが適切に記述されているか、実際のコードに対して十分なカバレッジがあるかを確認します。

---

#### 11. **構造体からクラスへの移行に関するテスト戦略**
   - **フェーズ移行時のテスト**
     - フェーズ1の構造体から、フェーズ2のクラスへの移行時には、同一のテストケースが新実装でも通過することを確認します。
     - フェーズ2ではコードカバレッジの計測を開始し、新しいクラスベースの実装のカバレッジも確保します。
   - **リファクタリングテスト**
     - リファクタリング後も機能が維持されているか確認するために、既存のテストスイートを活用します。
   - **互換性テスト**
     - 新旧両方のインターフェースが一時的に共存する場合、両方のインターフェースで同じ結果が得られることを確認します。

---

#### 12. **テストデータの管理**
   - **フィクスチャ**
     - 共通のテストデータは `test/fixtures/` ディレクトリに配置し、複数のテストで再利用します。
   - **モック・スタブ**
     - 外部依存（ファイルシステム、乱数発生器など）のモックは、Google Mockを使用して作成します。
   - **初期状態の設定**
     - 各テストケース開始時に、エージェントや市場の初期状態を定義する方法を統一します。
     - 具体的には、`SetUp()` メソッド内で初期化するか、テストフィクスチャを使用します。

---

#### 13. **シミュレーション固有のテスト戦略**
   - **確率的要素のテスト**
     - 乱数に依存する処理は、テスト時に決定論的な結果が得られるよう、乱数発生器をモック化します。
     - 特定の経済イベント（飢饉、戦争等）の影響をテストする際は、イベント発生を強制的にトリガーする機能を実装します。
   
   - **長時間シミュレーションのテスト**
     - 数百日~数千日の長期シミュレーションを高速実行し、システムの安定性を確認します。
     - メモリリークや計算量の爆発が発生しないことを検証します。
   
   - **エッジケースのテスト**
     - 極端な経済状況（超インフレ、全企業の破産など）においてもシステムが適切に動作するか検証します。
     - 負の価格や在庫、異常に高い価格など、想定外の状態への対応を確認します。




---